[
  {
    "objectID": "publications.html",
    "href": "publications.html",
    "title": "publications",
    "section": "",
    "text": "* denotes first or co-first authorship\n{% assign thumbnail=“left” %}\n{% for pub in site.data.publications %}\n{% if pub.pdf and pub.software %} {{pub.title}} {{pub.authors}}  {{pub.journal}} ({{pub.year}}) [PDF] [Software] {% elsif pub.software %} {{pub.title}} {{pub.authors}}  {{pub.journal}} ({{pub.year}}) [Software] {% elsif pub.pdf %} {{pub.title}} {{pub.authors}}  {{pub.journal}} ({{pub.year}}) [PDF] {% else %} {{pub.title}} {{pub.authors}}  {{pub.journal}} ({{pub.year}}) {% endif %}\n{% endfor %}"
  },
  {
    "objectID": "publications.html#publications",
    "href": "publications.html#publications",
    "title": "publications",
    "section": "",
    "text": "* denotes first or co-first authorship\n{% assign thumbnail=“left” %}\n{% for pub in site.data.publications %}\n{% if pub.pdf and pub.software %} {{pub.title}} {{pub.authors}}  {{pub.journal}} ({{pub.year}}) [PDF] [Software] {% elsif pub.software %} {{pub.title}} {{pub.authors}}  {{pub.journal}} ({{pub.year}}) [Software] {% elsif pub.pdf %} {{pub.title}} {{pub.authors}}  {{pub.journal}} ({{pub.year}}) [PDF] {% else %} {{pub.title}} {{pub.authors}}  {{pub.journal}} ({{pub.year}}) {% endif %}\n{% endfor %}"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "posts/2023-08-29-simulating-populations/index.html",
    "href": "posts/2023-08-29-simulating-populations/index.html",
    "title": "Simulating discrete and continuous populations",
    "section": "",
    "text": "library(gtools)"
  },
  {
    "objectID": "posts/2023-08-29-simulating-populations/index.html#introduction",
    "href": "posts/2023-08-29-simulating-populations/index.html#introduction",
    "title": "Simulating discrete and continuous populations",
    "section": "Introduction",
    "text": "Introduction\nOftentimes, we want to simulate populations in order to do some analysis. In this demo, I go over a, perhaps, crude way to mimic discrete and continuous populations. Before simulating, we need to know what a population is. In genetics, a population is a grouping of individuals based on some similarity in allele frequencies between them. Of course, there are many other definitions of what a population is. In this demo, I will use the definition based on allele frequencies.\nOne way to generate allele frequencies that mimic that seen in typical populations is to use the \\(F_{ST}\\), AKA the fixation index, AKA F-statistic. \\(F_{ST}\\) measures population differentiation as a result of genetic structure. Values range between 0 and 1, and higher values mean that two populations are highly similar. There are many definitions of \\(F_{ST}\\), depending on what you are discussing - and I am still learning about most of them. In this case, however, I am primarily concerned with allele frequency-related definitions.\n\nSimulating discrete populations\nTo simulate populations based on the definition of \\(F_{ST}\\), one thing we can do is to simulate an ancestral population’s allele frequencies. This is similar to having a founder population from which every other population descends. Afterwards, we can simulate different populations from this ancestral population. This follows from the Balding-Nichols model.\n\\[\\begin{align}\nBeta(\\frac{1-F}{F}p, \\frac{1-F}{F}(1-p))\n\\end{align}\\]\nAssume that we have 500 alleles/loci, and 4 populations, and we intend to simulate 1000 individuals from each of these populations. We can define our \\(F_{ST}\\) to be, say, 0.09 between populations 1 and 2, 0.19 between populations 1 and 2, and population 3, and 0.4 between all these populations, and population 4. Therefore, populations 1 and 2 will be closely related, and different from population 3, and all of them will be different from population 4.\n\nM &lt;- 500 # number of alleles or SNPs\nn_pops &lt;- 4 # number of populations\nN &lt;- 1000 # 20 individuals in each n_pops\nf_pop12 &lt;- 0.09\nf_pop3 &lt;- 0.19 # a third, distant, unrelated population\nf_pop4 &lt;- 0.4 # a fourth population\n\nWhen we make plots of the allele frequencies of these populations, we expect high correlations between populations 1 and 2, and not-so-high correlations when we compare with the other populations 3 and 4.\nWe can generate some random minor allele frequencies (MAFs) to be the ancestral allele frequencies, and generate independent draws from the distribution of the ancestral allele frequencies, based on the equation above.\n\nancestral_allele_freqs &lt;- runif(M, 0.01, 0.5)\nsh1 &lt;- ((1-f_pop12)/f_pop12)*ancestral_allele_freqs\nsh2 &lt;- ((1-f_pop12)/(f_pop12))*(1-ancestral_allele_freqs)\npop1_allele_freqs &lt;- rbeta(M, shape1 = sh1, shape2 = sh2)\npop2_allele_freqs &lt;- rbeta(M, shape1 = sh1, shape2 = sh2)\npop3_allele_freqs &lt;- rbeta(M, shape1 = ((1-f_pop3)/f_pop3)*ancestral_allele_freqs, shape2=((1-f_pop3)/(f_pop3))*(1-ancestral_allele_freqs))\npop4_allele_freqs &lt;- rbeta(M, shape1 = ((1-f_pop4)/f_pop4)*ancestral_allele_freqs, shape2=((1-f_pop4)/(f_pop4))*(1-ancestral_allele_freqs))\n\nall_allele_freqs &lt;- list(pop1_allele_freqs, pop2_allele_freqs, pop3_allele_freqs, pop4_allele_freqs)\nnames(all_allele_freqs) &lt;- paste0('population_', 1:4)\n\n\nFirst, how does the expected value of the distribution of allele frequency changes as a factor of the \\(F_{ST}\\)? This should give us an idea of what to expect when we simulate allele frequencies.\n\n# generate many Fst values\nfst_vector &lt;- round(seq(0.01, 0.99, length.out=20), 2) # 20 fsts ranging from 0.01 to 0.99\nper_fst &lt;- lapply(fst_vector, function(each_fst){\n  \n  sh1 &lt;- ((1-each_fst)/each_fst)*ancestral_allele_freqs\n  sh2 &lt;- ((1-each_fst)/(each_fst))*(1-ancestral_allele_freqs)\n  temp_allele_frq &lt;- rbeta(M, shape1 = sh1, shape2 = sh2)\n  deviation &lt;- cor(ancestral_allele_freqs, temp_allele_frq) #|&gt; suppressWarnings()\n  return(deviation)\n})\n\n\ncor_deviation &lt;- per_fst |&gt; unlist()\n\nplot(cor_deviation, frame.plot=F, xaxt='n', yaxt='n', type='b', xlab = expression(F[ST]), ylab=expression(R^2))\naxis(1, at=rep(1:length(cor_deviation), by=1), labels = fst_vector, las=2)\naxis(2, at=seq(0, 1, 0.1))\n\n\n\n\nWe see that as the \\(F_{ST}\\) increases, the correlation between the ancestral allele frequency and the generated allele frequency reduces.\n\nlayout(matrix(c(1,2,3,4,5,6), nrow = 2, ncol = 3, byrow = T))\nnames_pop &lt;- names(all_allele_freqs)\nfor(i in 1:4){\n    for(j in 1:4){\n        if(i == j){ # we don't want to plot pop1 vs pop1 e.t.c.\n            next\n        } else if (i &lt; j) {\n            #cor_ &lt;- round(cor(all_allele_freqs[[i]], all_allele_freqs[[j]]), 2)\n            plot(all_allele_freqs[[i]], all_allele_freqs[[j]], xlab = names_pop[i], ylab = names_pop[j], frame.plot = F)\n            #abline(a=0, b=cor_, col='red')\n            #mtext(cor_)\n        }\n    }\n}\nmtext('Scatterplot of allele frequencies for each population', outer = T)\n\n\n\n\nThe plot is approximately (roughly?) what we expect!"
  },
  {
    "objectID": "posts/2023-08-29-simulating-populations/index.html#simulating-genotypes-using-these-allele-frequencies",
    "href": "posts/2023-08-29-simulating-populations/index.html#simulating-genotypes-using-these-allele-frequencies",
    "title": "Simulating discrete and continuous populations",
    "section": "Simulating genotypes using these allele frequencies",
    "text": "Simulating genotypes using these allele frequencies\nGiven these allele frequencies, we can simulate genotypes from each of these populations by sampling from a binomial distribution.\n\\[\\begin{align}\nG_{k_{n}} \\sim Binom(n, p_{k})\n\\end{align}\\]\nwhere \\(n\\) is the number of success, and \\(p\\) is the probability of a success. Here, \\(n = 2\\) because we want 2 alleles per loci, and \\(p\\) is the allele frequency at that loci.\n\ngenotypes &lt;- lapply(seq_along(all_allele_freqs), function(i){\n    matrix(data=rbinom(n=N*M, size=2, prob = all_allele_freqs[[i]]), nrow = N, ncol = M, byrow = T)\n})\n\ngenotypes &lt;- do.call(rbind, genotypes)\nshuffle &lt;- sample(1:nrow(genotypes)) # I will shuffle the data\ngenotypes &lt;- genotypes[shuffle, ]\npops &lt;- rep(names(all_allele_freqs), each=N)\npops &lt;- pops[shuffle] # shuffle pops too, since it tells me what populations the genotypes come from\n\ncat('Here is what the genotypes look like\\n')\n\nHere is what the genotypes look like\n\ngenotypes[1:5, 1:5]\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    0    1    1    0    0\n[2,]    0    1    1    1    0\n[3,]    1    0    0    0    1\n[4,]    1    2    0    1    0\n[5,]    2    0    0    1    1\n\ncat('And here is what the population designation looks like \\n')\n\nAnd here is what the population designation looks like \n\npops[1:5]\n\n[1] \"population_3\" \"population_3\" \"population_4\" \"population_2\" \"population_4\"\n\n\nNext, we can calculate the principal components (PCs) of this data, and plot PC1 vs PC2, to see where the most variability lies in the data\n\n# first change the row names of the genotype data to reflect the populations\n#rownames(genotypes) &lt;- pops\n# I need to make sure that there are some variations in the SNPS - if there aren't any, I should remove them\npca_genotypes &lt;- genotypes[ , which(apply(genotypes, 2, var) != 0)]\n# PCA\npca_dt &lt;- prcomp(pca_genotypes, scale.=T, center=T)\npca_dt$x[1:5, 1:5]\n\n           PC1        PC2        PC3         PC4         PC5\n[1,] -6.301777 -8.6557677 -1.4686446  0.10914767 -0.45947344\n[2,] -5.655073 -8.9799929 -0.6363824 -1.01896071  0.03031705\n[3,] 12.897867 -1.1569598  0.2136605  1.16684731  0.22019343\n[4,] -3.703801  5.6955943 -5.2138878 -1.48900414  1.62677069\n[5,] 12.746688  0.3596545 -0.3268603 -0.03977012  0.25887077\n\n\n\n# colors\nmycolors &lt;- colorRampPalette(RColorBrewer::brewer.pal(8, \"Dark2\"))(n_pops)\n#mycolors &lt;- c('red', 'orange', 'green', 'blue')\ncolor_coding &lt;- factor(pops, labels = mycolors)\nplot(pca_dt$x[, 'PC1'], pca_dt$x[, 'PC2'], bg=as.character(color_coding), xlab = 'PC1', ylab = 'PC2', frame.plot = F, pch=21, main='PC1 vs PC2 of 4 discrete populations')\nlegend('topleft', legend=names_pop, pch=c(21, 21, 21, 21), pt.bg=mycolors, bty = 'n', xpd=NA)\n\n\n\n\nWe can look at populations 1 and 2 only, and see if there is any difference between them.\n\npop_names &lt;- c('population_1', 'population_2')\nidx &lt;- which(pops %in% pop_names)\npca_12 &lt;- pca_dt$x[idx, ]\ncolor_coding &lt;- factor(pops[idx], labels = mycolors[1:2])\nplot(pca_12[, 'PC1'], pca_12[, 'PC2'], bg=as.character(color_coding), xlab = 'PC1', ylab = 'PC2', frame.plot = F, pch=21, main='PC1 vs PC2 of the 2 similar populations 1 and 2')\nlegend('topleft', legend=pop_names, pch=c(21, 21), pt.bg=mycolors[1:2], bty = 'n', xpd=NA)\n\n\n\n\n\nSimulating continuous populations\nWhat I have done so far, is to simulate a discrete population of individuals. Think of it as people living in Mars, Earth, and Jupiter, and who have never intermingled since time immemorial. Population 3 is faraway from population 4. However, true human populations are not this way. How can we simulate a truly continuous population?\nFirst, notice that I am only simulating allele frequencies. Therefore, I can put a prior on my earlier-defined beta distribution to model the probability that an individual is from population \\(m\\). In other words, I am trying to estimate what percentage of an individual’s alleles might have come from a certain population \\(m\\). I will call this random variable, \\(Q\\).\n\\[\\begin{align}\nQ \\sim Dirichlet(\\alpha)\n\\end{align}\\]\nA trick I can use is to take an individual, ask how much of their genome is shared among each population I have, select that proportion of allele frequencies, and simulate their genotypes based on the selection for each population. To do this, I need to know how to distribute the \\(\\alpha\\) parameter used in the Dirichlet distribution. A trick I can use is to use the allele frequency distribution in the entire population. I will call this distribution the population grade distribution.\nEarlier, I simulated some allele frequencies all_allele_freqs\n\nss &lt;- sapply(all_allele_freqs, sum)\npopulation_grade &lt;- ss/sum(ss)\n#population_grade &lt;- rand_vect_cont(4, 1)\npopulation_grade\n\npopulation_1 population_2 population_3 population_4 \n   0.2409514    0.2482523    0.2595633    0.2512330 \n\n\nThen I can use this as a parameter to the Dirichlet distribution to simulate the percentage of an individual’s genotypes that is shared across all 4 populations.\n\nq_matrix &lt;- gtools::rdirichlet(N * n_pops, alpha = population_grade) # I want to simulate, N individuals per population\n\nHere is an illustration. Assuming that I am looking at the first individual\n\n# assuming one individual\nid1 &lt;- q_matrix[1, ]\nq_counts &lt;- floor(id1 * M) # number of loci shared\nq_counts\n\n[1]   0 422  66  11\n\n\nThe assumption here is that this individual shares 0 loci with population 1, 422 with population 2, 66 with population 3, and 11 loci with population 4, and 3 independent loci not share with any population. The sum is 499 (because I rounded down), but I don’t want this to be this case. Therefore, I will share the remaining loci with the highest number already available, so that the sum is 500.\n\nremainder_ &lt;- M - sum(q_counts)\nq_counts[which.max(q_counts)] &lt;- q_counts[which.max(q_counts)] + remainder_\nq_counts\n\n[1]   0 423  66  11\n\n\nNow, this sums to 500.\nPutting this into a reusable function…\n\nq_counts_fxn &lt;- function(q_matrix, M){\n    apply(q_matrix, 1, function(each_row){\n        temp &lt;- floor(each_row * M)\n        remainder_ &lt;- M - sum(temp)\n        temp[which.max(temp)] &lt;- temp[which.max(temp)] + remainder_\n        temp\n    }) |&gt; t()\n}\n\nq_counts &lt;- q_counts_fxn(q_matrix, M)\nq_counts[1:5, ] # for the first 5 individuals\n\n     [,1] [,2] [,3] [,4]\n[1,]    0  423   66   11\n[2,]    0    0   20  480\n[3,]  458    0   15   27\n[4,]   73    0  415   12\n[5,]   90  401    0    9\n\n\n\ngenotypes &lt;- matrix(NA, nrow = N*n_pops, ncol = M) # remember, N individuals per population\n\nfor(q in 1:nrow(q_counts)){\n    pop_down &lt;- 1\n    m_loci &lt;- 1:M\n    i_loci &lt;- list() # this list contains the actual loci an individual has shared among the other populations\n    while(pop_down &lt;= ncol(q_counts)){\n        # sample pop 1 loci\n        pop_loci &lt;- sample(m_loci, size=q_counts[q, pop_down], replace = F)\n        if(length(pop_loci) == 0){\n            m_loci &lt;- m_loci[m_loci != 0]\n            i_loci[[pop_down]] &lt;- 0\n        } else {\n            m_loci &lt;- m_loci[!m_loci %in% pop_loci]\n            i_loci[[pop_down]] &lt;- pop_loci\n        }\n        pop_down &lt;- pop_down + 1\n    }\n    \n    g_loci &lt;- lapply(seq_along(i_loci), function(i){\n        temp &lt;- all_allele_freqs[[i]][i_loci[[i]]]\n        rbinom(n = length(temp), size = 2, prob = temp)\n    })\n\n    gi &lt;- vector(mode='numeric', length = M)\n    for(i in 1:n_pops){\n        gi[i_loci[[i]]] &lt;- g_loci[[i]]\n    }\n    \n    genotypes[q, ] &lt;- gi\n    \n}\n\n\npop &lt;- paste0('population_', apply(q_counts, 1, which.max))\n# first change the row names of the genotype data to reflect the populations\nrownames(genotypes) &lt;- pop\n# I need to make sure that there are some variations in the SNPS - if there aren't any, I should remove them\npca_genotypes &lt;- genotypes[ , which(apply(genotypes, 2, var) != 0)]\n# PCA\npca_dt &lt;- prcomp(pca_genotypes, scale.=T, center=T)\npca_dt$x[1:5, 1:5]\n\n                    PC1       PC2         PC3        PC4         PC5\npopulation_2   2.630499 -4.567577 -5.04236841 -0.6308499 -2.47871584\npopulation_4 -11.768347  1.467939 -1.86696415  1.0625678 -0.09644552\npopulation_1   3.273803 -3.865039  4.72494514  1.4144551  2.76600329\npopulation_3   5.343715  5.836493 -0.04239426 -0.4738707  1.02523977\npopulation_2   1.961908 -4.370135 -3.31504203  0.8165656  0.11845564\n\n\n\nmycolors &lt;- colorRampPalette(RColorBrewer::brewer.pal(8, \"Dark2\"))(n_pops)\ncolor_coding &lt;- factor(rownames(pca_dt$x), labels = mycolors)\nplot(pca_dt$x[, 'PC1'], pca_dt$x[, 'PC2'], bg=color_coding |&gt; as.character(), xlab = 'PC1', ylab = 'PC2', frame.plot = F, pch=21, main='PC1 vs PC2 of 4 continuous populations')\nlegend('topleft', legend=names_pop, pch=c(21, 21, 21, 21), pt.bg=mycolors, bty = 'n', xpd = NA)"
  },
  {
    "objectID": "posts/2023-08-29-testing/index.html",
    "href": "posts/2023-08-29-testing/index.html",
    "title": "Testing",
    "section": "",
    "text": "2 + 2\n\n[1] 4"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Temi’s website",
    "section": "",
    "text": "My name is Temi, and I’m a PhD student in the Genetics, Genomics and Systems biology (GGSB{:target=“_blank”}) program at the University of Chicago. Prior to this, I completed a master’s at the University of North Dakota, supervised by the awesome Junguk Hur{:target=“_blank”}.\n\nIn Fall 2022, I joined Haky’s lab{:target=“_blank”} for my PhD thesis. Here, I will be using computation, statistics and whatever means necessary (no kidding) to understand genetic data in relation to phenotypes. Specifically, I will be studying variations in the human epigenome (at the genomic level and the population level), how these variations influence molecular-level activities (e.g. TF binding), and how these, in turn, influence complex traits and diseases. These are complex questions. Wish me luck!\nHere is my cv and a list of publications that I have contributed to.\n\nYou can reach me by filling this form{:target=“_blank”} or through my social media pages below."
  },
  {
    "objectID": "index.html#home",
    "href": "index.html#home",
    "title": "Temi’s website",
    "section": "",
    "text": "My name is Temi, and I’m a PhD student in the Genetics, Genomics and Systems biology (GGSB{:target=“_blank”}) program at the University of Chicago. Prior to this, I completed a master’s at the University of North Dakota, supervised by the awesome Junguk Hur{:target=“_blank”}.\n\nIn Fall 2022, I joined Haky’s lab{:target=“_blank”} for my PhD thesis. Here, I will be using computation, statistics and whatever means necessary (no kidding) to understand genetic data in relation to phenotypes. Specifically, I will be studying variations in the human epigenome (at the genomic level and the population level), how these variations influence molecular-level activities (e.g. TF binding), and how these, in turn, influence complex traits and diseases. These are complex questions. Wish me luck!\nHere is my cv and a list of publications that I have contributed to.\n\nYou can reach me by filling this form{:target=“_blank”} or through my social media pages below."
  }
]